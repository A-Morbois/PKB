# Docker
tags = #Devops #Linux


The application your containerasing must be a linux one.
VM = abstract system hardware
Container = abstract the application // use the same system hardware

Dockerfile is needed only if you want to build an image

	## Basis

`docker images` -> list your images
`docker run` -> will automatically fetch the images if you don't have it.
`docker fetch` -> only fetch the images and not start it.
`docker run --detach <ImageName>` -> will run the container in the background // or -d
`docker run --name <ContainerName> <ImageName>` -> give a name to your container so it's easier to use
`docker ps` -> list the running container
`docker rm <ContainerName>` -> remove the a container
`docker start /stop / restart <ContainerName>` 
`docker run -itd <ContainerName>` -> i = interactive t = tty -> you can interract with your container // will run a sh command
`docker attach <ContainerName>` -> go inside the container
`docker run --rm <ContainerName>` -> will be deleted when finished

	## networking

- Closed networking model: cannot communicate, even with the host `docker run --net none `
- Bridged networking model: By default  `docker run --net bridge `(or just `docker run`)
	* `docker run -p 80 ` -> set a random port from the host to redirect to the port 80 from the guest 
	* `docker run -p 8080:80` -> set the port 8080 from the host to redirect to the port 80 from the guest 
	* `docker run -p 127.0.0.1:8080:80` -> redirect only for the local traffic. Else it can be access from the outside using the docker ip adress (interface docker0)

- Open networking model: 
`docker run --net host` -> as if the container is using the host port // container accessible from the outside. Be careful.

	## Storage

- Bind : `docker run -v <path_to_host>:<path_to_container>`
	ex : `docker run -v "$(pwd)"<path_to_container>`
